#include <stdio.h>
 
/* colljp.c : collation in Japanese locale
 * (c) Masayuki TOYOSHIMA, 1991. All rights reserved.
 * feel free to copy and distribute under the GNU Public Licence.
 * send bug reports and/or suggestions to
 *      mtoyo@Lit.hokuda.ac.jp, MHA00720@niftyserve.or.jp
 */
 
 static char *copyright=" colljp.c:copyright (C) TOYOSHIMA, Masayuki, 1991. ";
 static char *version= " v00-00 ";
 static char
  *Last_updated= "$Header: /home/mtoyo/sortf/sortf.10b/colljp.c,v 1.1 1994/08/21 13:26:25 mtoyo Exp mtoyo $";
 
/* ================================================================
 *  Nota bene
 * ----------------------------------------------------------------
 * o This file can be compiled only by Multi-byte sensitive compilers.
 *
 * o This file itself contains no Multi-byted Japanese Kanji characters
 *   but files included have lots of them.
 *
 */
 
#include "mtconfig.h"
#include <assert.h>
 
/*
 *===================================================
 *              limits
 *===================================================
 */
 
#ifndef MAX_COMPARE_CHARACTERS
#define MAX_COMPARE_CHARACTERS  (48)  /*longer strings not properly collated*/
#endif
 
/*
 *===================================================
 *              types
 *===================================================
 */
 
typedef unsigned short  FLAG;
typedef char            SMALLINT;
typedef struct t_table_type {
    const char  *tbl_entry;     /* original string */
    const char  *tbl_skelton;   /* skelton form for rudimental comparison */
    const char  *tbl_vowel;     /* vowels : applicable only to KANA strings */
    FLAG        tbl_flag;       /* flag for special effects */
    SMALLINT    tbl_len;        /* size of original string */
    SMALLINT    tbl_genre;      /* genre of string */
} table_type;
 
/*
 *===================================================
 *              mnemonics
 *===================================================
 */
 
    /* mnemonic for character genres */
 
#define GR_SPACE    1               /* spaces */
#define GR_PUNCT    (GR_SPACE + 1)  /* punctuations */
#define GR_PAREN    (GR_PUNCT + 1)  /* parentheses */
#define GR_MATH     (GR_PAREN + 1)  /* mathematical symbols */
#define GR_COMMON   (GR_MATH  + 1)  /* other common symbols */
#define GR_UNIT     (GR_COMMON + 1) /* unit symbols */
#define GR_ALPHA    (GR_UNIT  + 1)  /* non-Latin alphabets (Cyrillic/Greek) */
#define GR_LATIN    (GR_ALPHA + 1)  /* Latin alphabets */
#define GR_DIGIT    (GR_LATIN + 1)  /* digits */
#define GR_KANA     (GR_DIGIT + 1)  /* Japanese KANA (HIRAGANA/KATAKANA) */
#define GR_KANJI    (GR_KANA  + 1)  /* KANJI */
#define GR_GETA     (GR_KANJI + 1)  /* non-existant type symbol */
 
    /* mnemonic for character features (flags)
     * NB. some features are dependent on each other,
     * but made independent for the sake of easy initialization.
     */
#define FL_DAKUON       ((FLAG)(0x01))  /* Japanese voiced consonantal */
#define FL_HANDAKUON    ((FLAG)(0x02))  /* Japanese P-sound consonantal */
#define FL_ODORI        ((FLAG)(0x04))  /* repeat (`bis') marks */
#define FL_CHOUON       ((FLAG)(0x08))  /* vowel prolongation marks */
#define FL_KATAKANA     ((FLAG)(0x10))  /* KATAKANA (not HIRAGANA) */
#define FL_small        ((FLAG)(0x20))  /* small-faced types */
#define FL_lower        ((FLAG)(0x40))  /* lower-cases for Latin alphabets */
#define FL_upper        ((FLAG)(0x80))  /* upper-cases */
 
/*
 *===================================================
 *              initialization
 *===================================================
 */
 
 /*
  * NB. initialization table is made by perl script `mkjptbl.pl',
  * and included as `jptbl.h'
  *
  */
static table_type colljp_const_table[]= {
#include "jptbl.h"  /* this table is generated by mkjptbl.pl */
};
#define SZ_colljp_const_table (sizeof(colljp_const_table)/sizeof(table_type))
 
 
/*
 *===================================================
 *              subroutine prototypes
 *===================================================
 */
 
#if (defined(HAS_FUNCTION_PROTOTYPE))
  DCL_PRIVATE int cmp_flag(const FLAG *L_flag,const FLAG *R_flag,const int len);
  DCL_PRIVATE int cmp_skelton(FLAG *flag_left,const UCHAR **next_left,const UCHAR *left,
                FLAG *flag_right, const UCHAR **next_right, const UCHAR *right,
                int L_len, int R_len,int *number_of_compared_characters,
                table_type *L_table, table_type *R_table, const UNIV *table);
  DCL_PRIVATE table_type *get_table(const UCHAR *string,
                table_type *buf, const UNIV *table);
  DCL_PRIVATE table_type *get_skelton(const UCHAR *s_in,
                const table_type *tbl_preceding,
                table_type *buf, const UNIV *table);
#else
  DCL_PRIVATE int cmp_flag(), cmp_skelton();
  DCL_PRIVATE table_type *get_table(), *get_skelton();
#endif
 
#ifndef max
#define max(a,b)    (((a)<(b))?(b):(a))
#endif
#ifndef min
#define min(a,b)    (((a)>(b))?(b):(a))
#endif
 
#include "colljp.h"
#include "mbjp.h"
 
/*
 *===================================================
 *              public functions
 *===================================================
 */
 
int colljp(left,right,left_len,right_len,table)
    BUSY const UCHAR *left, *right; int left_len, right_len; const UNIV *table;
{
    BUSY int    diff;
    table_type  buf_L, buf_R;
    FLAG        L_flagbuf[MAX_COMPARE_CHARACTERS],
                R_flagbuf[MAX_COMPARE_CHARACTERS];
    FLAG        *L_flag= L_flagbuf, *R_flag= R_flagbuf;
    memset(L_flagbuf,0,sizeof(L_flagbuf));  /* clear */
    memset(R_flagbuf,0,sizeof(R_flagbuf));
 
    if (left_len  > MAX_COMPARE_CHARACTERS) left_len=  MAX_COMPARE_CHARACTERS;
    if (right_len > MAX_COMPARE_CHARACTERS) right_len= MAX_COMPARE_CHARACTERS;
 
        /* compare character by charecter (NB. not byte by byte)
         * as long as both string exist.
         */
    while((left_len > 0) && (right_len > 0)) {
        BUSY table_type *L_tbl= get_table(left, &buf_L,table);
        BUSY table_type *R_tbl= get_table(right,&buf_R,table);
        BUSY int L_len= L_tbl->tbl_len;
        BUSY int R_len= R_tbl->tbl_len;
 
        if (diff= (L_tbl->tbl_genre - R_tbl->tbl_genre)) return diff;
        switch(L_tbl->tbl_genre) {
             case GR_SPACE  :
             case GR_PUNCT  :
             case GR_PAREN  :
             case GR_MATH   :
             case GR_COMMON  :
             case GR_UNIT   :
             case GR_ALPHA  :
             case GR_DIGIT :
                    /* these characters do not have contexts/special features,
                     * and can be compared simply character by character.
                     */
                if (diff=memcmp(L_tbl->tbl_skelton,R_tbl->tbl_skelton,SZ_MBCHR))
                    return diff;
                left_len -=  L_len; left+=  L_len;
                right_len -= R_len; right+= R_len;
                L_flag++; R_flag++;
                break;
             case GR_LATIN  :
             case GR_KANA   :
                    /* here we must refer to their contexts/special features */
                {
                    auto const UCHAR *next_left, *next_right;
                    auto int n_compared;
                    if (diff= cmp_skelton(L_flag,&next_left,left,
                              R_flag,&next_right,right,left_len,right_len,
                              &n_compared,L_tbl,R_tbl,table)) {
                        return diff;
                    }
                    left_len-=  (int)(next_left  - left);   left= next_left;
                    right_len-= (int)(next_right - right);  right= next_right;
                    L_flag += n_compared;
                    R_flag += n_compared;
                }
                break;
             case GR_KANJI  :
             case GR_GETA   :
                /* these characters do not have contexts/special features,
                 * and have no skelton string-values.
                 * can be compared simply character by character.
                 */
                if (diff= memcmp(left,right,SZ_MBCHR)) return diff;
                left_len -=  SZ_MBCHR;  left+=  SZ_MBCHR;
                right_len -= SZ_MBCHR;  right+= SZ_MBCHR;
                L_flag++; R_flag++;
                break;
            default :   /* undefined char (both !) */
                /* here you may say we must compare their lengths first,
                 * but we rather don't do that. see below.
                 */
                if (diff= memcmp(left,right,min(L_len,R_len))) return diff;
                    /* here we can refer to their coded-byte lengths,
                     * but we rather don't do that. see below.
                     */
                left_len -=  L_len; left+=  L_len;
                right_len -= R_len; right+= R_len;
                L_flag++; R_flag++;
                break;
        }
    }
        /* skeltons partially matched at left.
         * if either string has trailing part, that is longer.
         */
    if (diff= left_len - right_len) return diff;
 
        /* skeltons completely matched, and have same number of characteres.
         * we must compare features (`flags') of the skeltons.
         */
    if (diff= cmp_flag(L_flagbuf,R_flagbuf,(int)(L_flag- L_flagbuf)))
        return diff;
 
        /* at last we are here.
         * skeltons and flags completely matched.
         * does this mean strings are identical ?
         * Not quite, because they may differ in coded-bytes.
         * eg. 1-byted Latin and 2-byted latin are treated equally in
         * this collation. ie. we have been ignoring coded-byte lengths.
         *
         * Here, we can refer to ther coded-byte lengths as a last resort
         * to `use anything that can be differentiated' policy,  but,
         * we will rather let upper routines do that (they may find another :-)
         * and just return `could not find any difference' here.
         * to know the coded-bytelengths, just check *left/right_here value.
         */
    return 0;
}
 
int clscoll(table) UNIV *table;
{
    BUSY table_type ***buf_1st_byte, **buf_2nd_byte;
    if (buf_1st_byte= (table_type***)table) {
        if (buf_2nd_byte= *buf_1st_byte)    free(buf_2nd_byte);
        free(buf_1st_byte);
    }
    return 0;
}
 
UNIV *opncoll()
{
#define ERR_RETURN  ((UNIV *)0)
#define ROW_1       (UCHAR_MAX + 1)     /* one row of Multi-byte table */
    BUSY int        n_row, n;
    BUSY table_type **s, ***s_out;
    BUSY table_type *table;
    table_type      ***buf_1st_byte, **buf_2nd_byte;
 
    assert(SZ_MBCHR<=2); /* otherwise, must rewrite table structure */
 
        /* 1.   setup memory for 1st bytes */
    buf_1st_byte= (table_type ***)calloc(sizeof(table_type **),UCHAR_MAX+1);
    if (!buf_1st_byte)      /* out of memory */         return ERR_RETURN;
    if ((n_row= mbopen()) < 0)  {
        free(buf_1st_byte);                             return ERR_RETURN;
    }
        /* 2. setup memory for 2nd bytes */
    buf_2nd_byte= (table_type**)
        calloc(sizeof(table_type*),(size_t)((ROW_1 * n_row) + UCHAR_MAX + 1));
    if (!buf_2nd_byte) {
        free(buf_1st_byte);                             return ERR_RETURN;
    }
        /* 3. let each cell of 1st_byte table points to 2nd byte location.
         *    note that *buf_1st_byte == buf_2nd_byte (for ease of freeing)
         */
    for(s= buf_2nd_byte,s_out= buf_1st_byte,n= 0; n <= UCHAR_MAX; n++,s_out++){
        *s_out= s;
        s += ((is_MBYTE(n))? ROW_1 : 1);
    }
        /* 4. let each cell of buf_1st_byte points to colljp_const_table */
    table= colljp_const_table;
    for(n= 0; n < SZ_colljp_const_table; n++, table++) {
        BUSY UCHAR *str= (UCHAR *)(table->tbl_entry);
        if (is_MBYTE(*str)) { /* has 2nd byte */
            *(*(buf_1st_byte + *str) + *(str + 1))= table;
        } else {
            *(*(buf_1st_byte + *str))= table;
        }
        if (!(table->tbl_len)) table->tbl_len= strlen(table->tbl_entry);
    }
    return (UNIV *)buf_1st_byte;
#undef ROW_1
#undef ERR_RETURN
}
 
/*
 *===================================================
 *              private functions
 *===================================================
 */
 
PRIVATE
int cmp_flag(L_flag,R_flag,len_flag)
    const FLAG *L_flag,*R_flag; BUSY const int len_flag;
{
/*  when string completely match by skeltons, must compare flags.
 *
 *  ------------------------------------------------------
 *      NB.  PRECEDENCE GIVEN HERE IS SUBJECT TO CHANGE
 *  ------------------------------------------------------
 *
 *  the precedence of flags are
 *  for Latin alphabets
 *      1.  lower-case < upper-case
 *  for Japanese KANA strings
 *      1.  SEION < DAKUON < HANDAKUON
 *      2.  CHOUON < KOMOJI < ODORI (`bis' mark) < OOMOJI
 *      3.  HIRAGANA < KATAKANA
 */
 
#define PREC(f,name,value)  ((f) & (name))?(value)
#define mask_upper(f)   (PREC((f),FL_upper,1):0)
#define mask_DAKUON(f)  (PREC((f),FL_DAKUON,1):(PREC((f),FL_HANDAKUON,2):0))
#define mask_CHOUON(f)  (PREC((f),FL_CHOUON,0):(PREC((f),FL_small,1):(PREC((f),FL_ODORI,2):3)))
#define mask_KANA(f)    (PREC((f),FL_KATAKANA,1):0)
 
    BUSY int len, len_start;
    BUSY const FLAG *L_val= L_flag, *R_val= R_flag;
    const FLAG *L_start, *R_start;
 
        /* 0. skip to left-most differ point */
    for(len_start= 0; len_start < len_flag; len_start++) {
        if ((*L_val) != (*R_val)) break;
        L_val++; R_val++;
    }
    if (len_start >= len_flag)  /* left and right are identical */
        return 0;
 
        /* now, L_val/R_val points where they differ */
    L_start= L_val; R_start= R_val;
 
        /* 1. lower/upper */
    L_val= L_start; R_val= R_start;
    for(len= len_start; len < len_flag; len++) {
        BUSY int diff;
        if (diff=  (mask_upper(*L_val) - mask_upper(*R_val)))   return diff;
        L_val++; R_val++;
    }
        /* 2. SEION/DAKUON */
    L_val= L_start; R_val= R_start;
    for(len= len_start; len < len_flag; len++) {
        BUSY int diff;
        if (diff=  (mask_DAKUON(*L_val) - mask_DAKUON(*R_val))) return diff;
        L_val++; R_val++;
    }
        /* 3. CHOUON/ODORI */
    L_val= L_start; R_val= R_start;
    for(len= len_start; len < len_flag; len++) {
        BUSY int diff;
        if (diff=  (mask_CHOUON(*L_val) - mask_CHOUON(*R_val))) return diff;
        L_val++; R_val++;
    }
        /* 4. KATAKANA/HIRAGANA */
    L_val= L_start; R_val= R_start;
    for(len= len_start; len < len_flag; len++) {
        BUSY int diff;
        if (diff=  (mask_KANA(*L_val) - mask_KANA(*R_val)))     return diff;
        L_val++; R_val++;
    }
    return 0;
#undef mask_KANA
#undef mask_CHOUON
#undef mask_DAKUON
#undef PREC
}
 
PRIVATE
int cmp_skelton(L_flag,next_left,left,R_flag,next_right,right,
                L_len,R_len,n_used_chars,L_tbl,R_tbl,tbl)
    BUSY FLAG   *L_flag; const UCHAR **next_left;   const UCHAR *left;
    BUSY FLAG   *R_flag; const UCHAR **next_right;  const UCHAR *right;
    int          L_len, R_len ,*n_used_chars;
    table_type  *L_tbl, *R_tbl; const UNIV *tbl;
{
        /* compare skeltons as long as they are of the same genre */
    table_type  L_tbl_buf[MAX_COMPARE_CHARACTERS], R_tbl_buf[MAX_COMPARE_CHARACTERS];
    BUSY table_type *sL_buf= L_tbl_buf, *sR_buf= R_tbl_buf;
 
    *n_used_chars= 0;
    while(L_tbl && R_tbl) { /* as long as skelton of current genre exists */
        BUSY int diff;
        left  += L_tbl->tbl_len; L_len -= L_tbl->tbl_len;
        right += R_tbl->tbl_len; R_len -= R_tbl->tbl_len;
        if (diff= memcmp(L_tbl->tbl_skelton,R_tbl->tbl_skelton,SZ_MBCHR)) {
            *next_left= left; *next_right= right;
            return diff;
        }
            /* skelton matched */
        *n_used_chars+= 1;
        *L_flag++= L_tbl->tbl_flag; *R_flag++= R_tbl->tbl_flag;
        if ((L_len > 0) && (R_len > 0)) {
            L_tbl= get_skelton(left, L_tbl,sL_buf,tbl); sL_buf++;
            R_tbl= get_skelton(right,R_tbl,sR_buf,tbl); sR_buf++;
                /* if genre of string changes, NULL is set to L_tbl/R_tbl */
        } else break; /* came to end of string */
    }
    *next_left= left; *next_right= right;
        /* either/both of the strings reached end,
         * or genres of skeltons differ in the middle of the string.
         * let upper routines compare them.
         */
    return 0;
}
 
PRIVATE
table_type *get_table(s, table_buf, generic_table)
    BUSY const UCHAR *s; table_type *table_buf; const UNIV *generic_table;
{
    BUSY table_type **byte_1st, *byte_2nd;
 
    byte_1st = *(((table_type***)generic_table) + *s);
    assert(byte_1st != NULL);
    byte_2nd= *((is_MBYTE(*s))? (byte_1st + *(s + 1)) : byte_1st);
    if (byte_2nd && (byte_2nd->tbl_entry)) return byte_2nd; /* defined char */
        /* else undefined character : copy it into table_buf */
    if (table_buf) {
        table_buf->tbl_entry= table_buf->tbl_skelton= (char*)s;
        table_buf->tbl_vowel= (char*)0;
        table_buf->tbl_flag=  (FLAG)0;
        table_buf->tbl_genre= (is_KANJI(*s))? GR_KANJI : (SMALLINT)0;
        table_buf->tbl_len=   (SMALLINT)((is_MBYTE(*s))? SZ_MBCHR : 1);
    }
    return table_buf;
}
 
PRIVATE
table_type *get_skelton(s_in,tbl_preceding,tbl_buf,table)
    const UCHAR *s_in;
    BUSY const table_type *tbl_preceding;
    table_type *tbl_buf; const UNIV *table;
{
    BUSY table_type *tbl= get_table(s_in,tbl_buf,table); /* get next */
 
    if (tbl->tbl_genre != tbl_preceding->tbl_genre) return (table_type*)0;
    if (tbl->tbl_flag & FL_ODORI) {
            /* copy old skelton and vowel */
        memcpy(tbl_buf,tbl,sizeof(table_type));
        tbl_buf->tbl_skelton=   tbl_preceding->tbl_skelton;
        tbl_buf->tbl_vowel=     tbl_preceding->tbl_vowel;
            /* NB : DAKUTEN flag in tbl_preceding maybe turned off */
        return tbl_buf;
    } else if (tbl->tbl_flag & FL_CHOUON) {
            /* copy old vowel to skelton */
        memcpy(tbl_buf,tbl,sizeof(table_type));
        tbl_buf->tbl_skelton= tbl_buf->tbl_vowel= tbl_preceding->tbl_vowel;
        return tbl_buf;
    }
    return tbl;
}
 
/*
 *===================================================
 *
 *              main routine for testing
 *
 *===================================================
 */
 
 
#if (DO_TEST)
/*******************************************************************
 *  a simple test routine for colljp.c
 *  usage : colljp input-1 input-2 > output
 *
 *  this routine compares 1 and 2, then sorts them all into output
 *******************************************************************
 */
    static UNIV *test_table;
 
#if (defined(HAS_FUNCTION_PROTOTYPE))
    DCL_PRIVATE int do_compare(const UNIV *s, const UNIV *t);
    DCL_PRIVATE void do_collsort(void);
    DCL_PRIVATE UCHAR *pop_rec(void);
    DCL_PRIVATE int push_rec(const UCHAR *s);
#else
    DCL_PRIVATE int do_compare();
    DCL_PRIVATE void do_collsort();
    DCL_PRIVATE UCHAR *pop_rec();
    DCL_PRIVATE int push_rec();
#endif
 
#if (defined(CPP_Borland))
    extern unsigned _stklen=24000;
#endif
 
int main(argc,argv) int argc; char *argv[];
{
    FILE    *fleft, *fright;
    UCHAR   *rec;
 
    if (argc > 2) {
        if (!(fleft= fopen(argv[1],"r"))) {
            fprintf(stderr," %s not found%c",argv[1],C_LF); exit(1);
        }
        if (!(fright= fopen(argv[2],"r"))) {
            fprintf(stderr," %s not found%c",argv[2],C_LF); exit(1);
        }
    } else {
        fprintf(stderr,"usage : colljp input-1 input-2 >output...%c",C_LF);
        exit(1);
    }
    if (!(test_table= opncoll())) {
        fprintf(stderr," out of memory.%c",C_LF); exit(1);
    }
 
    for(;;) {
        UCHAR   left[RECL_MAX + 1], right[RECL_MAX + 1];
        BUSY    int diff;
        if (!fgets((char*)left,RECL_MAX,fleft)) break;
        if (!fgets((char*)right,RECL_MAX,fright)) break;
        *(strchr(left,C_LF))= (UCHAR)0;     /* cut LF */
        *(strchr(right,C_LF))= (UCHAR)0;
        if (push_rec(left) || push_rec(right)) {
            fprintf(stderr," stack full...");
            break;
        }
        diff= colljp(left,right,strlen(left),strlen(right),test_table);
        printf(" %s %s %s%c",
            left, (diff<0)?" <":((diff>0)?" >":"=="),right,C_LF);
    }
    fclose(fleft);
    fclose(fright);
    fprintf(stderr, "%ccompare done, sorting...%c",C_LF,C_LF);
    do_collsort();
    clscoll(test_table);
    while(rec= pop_rec()) {
        UCHAR old_rec[RECL_MAX];
        if (strcmp(old_rec,rec)) {
            printf("%s%c",rec,C_LF);
            strcpy(old_rec,rec);
        }
    }
    exit(0);
}
 
    static UCHAR *rec_stack, *rec_stack_top, *rec_stack_tail;
    static UCHAR **rec_pointer;
    static size_t n_rec= 0, n_max;
 
PRIVATE
int do_compare(ss,tt) const UNIV *ss, *tt;
{
    BUSY UCHAR **s= (UCHAR**)ss;
    BUSY UCHAR **t= (UCHAR**)tt;
    BUSY int s_len= strlen(*s), t_len= strlen(*t);
    BUSY int diff;
    ((diff= colljp(*s,*t,s_len,t_len,test_table))
    ||  (diff= memcmp(*s,*t,max(s_len,t_len))));
    return diff * -1;
}
 
PRIVATE
void do_collsort()
{
    qsort(rec_pointer,n_rec,sizeof(UCHAR*),do_compare);
}
 
PRIVATE
UCHAR *pop_rec()
{
    if (n_rec) {
        return rec_pointer[--n_rec];
    } else {
        free(rec_pointer);
        free(rec_stack);
    }
    return (UCHAR*)0;
}
 
PRIVATE
int push_rec(s) const UCHAR *s;
{
    BUSY size_t len= strlen(s) + 1;
    if (!rec_stack) {
        BUSY size_t rec_sz= (size_t)(SIZE_T_MAX * 0.7);
        BUSY size_t pointer_sz= (size_t)(rec_sz / 8);
        if (!(rec_stack= (UCHAR*)calloc(sizeof(UCHAR),rec_sz)))
            return EOF;
        if (!(rec_pointer= (UCHAR**)calloc(sizeof(UCHAR*),pointer_sz)))
            return EOF;
        rec_stack_top= rec_stack;
        rec_stack_tail= rec_stack + rec_sz;
        n_rec= 0; n_max= n_rec + pointer_sz;
    }
    if (rec_stack && ((rec_stack_top + len) < rec_stack_tail) && (n_rec < n_max)) {
        memcpy(rec_stack_top,s,len);
        rec_pointer[n_rec++]= rec_stack_top;
        rec_stack_top+= len;
        return 0;
    }
    return EOF;
}
#endif
 
#if 0
<history>
 
v00-00 94/04/30 - 05/02 completely rewritten from scratch.
            tentative JIS draft conforming
#endif
